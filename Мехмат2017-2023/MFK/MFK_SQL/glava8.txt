Токаева Александра, мехмат, 3 курс, 03.05.20
Дз по главе 8

1) Предположим, что для какой-то таблицы создан уникальный индекс по двум столбцам: column1 и column2. В таблице есть строка, у которой значение ат- рибута column1 равно ABC, а значение атрибута column2 — NULL. Мы решили добавить в таблицу еще одну строку с такими же значениями ключевых атри- бутов, т. е. column1 — ABC, а column2 — NULL.
Как вы думаете, будет ли операция вставки новой строки успешной или завер- шится с ошибкой? Объясните ваше решение.

Ответ: я думаю, что новая строка добавится без ошибки, потому что у этих строк разные значения столбца column2, т.к SQL считает значения NULL уникальными, не равными в том числе и между собой.


3)Известно, что индекс значительно ускоряет работу, если при выполнении за- проса из таблицы отбирается лишь небольшая часть строк. Если же эта доля велика, скажем, половина строк или более, то большого положительного эффек- та от наличия индекса уже не будет, а возможно даже, что не будет практически никакого эффекта. Наша задача — проверить это утверждение на практике.
Обратимся к таблице «Перелеты» (ticket_flights). В ней имеется столбец «Класс обслуживания» (fare_conditions), который отличается от остальных тем, что в нем могут присутствовать лишь три различных значения: Comfort, Business и Economy.
Если секундомер в утилите psql выключен, то включите его.
Выполните запросы, подсчитывающие количество строк, в которых атрибут fare_conditions принимает одно из трех возможных значений. Каждый из запросов выполните три-четыре раза, поскольку время может немного изме- няться, и подсчитайте среднее время. Обратите внимание на число строк, ко- торые возвращает функция count для каждого значения атрибута. При этом среднее время выполнения запросов для трех различных значений атрибута fare_conditions будет различаться незначительно, поскольку в каждом слу- чае СУБД просматривает все строки таблицы.


demo=# SELECT count( * )
demo-# FROM ticket_flights
demo-# WHERE fare_conditions = 'Comfort';
 count 
-------
 17291
(1 row)

Time: 441,808 ms
Еще раз: Time: 138,684 ms
И еще раз: Time: 137,269 ms
Среднее время = 239,254 ms




demo=# SELECT count( * )
demo-# FROM ticket_flights
demo-# WHERE fare_conditions = 'Business';
 count  
--------
 107642
(1 row)

Time: 134,533 ms
Еще раз: Time: 135,644  ms
И еще раз: Time: 135,149 ms
Среднее время = 135,115 ms



demo=# SELECT count( * )
demo-# FROM ticket_flights
demo-# WHERE fare_conditions = 'Economy';
 count  
--------
 920793
(1 row)

Time: 164,573 ms
Еще раз:  Time: 164,961 ms  
И еще раз: Time: 163,748 ms
Среднее время = 164,427 ms



Создайте индекс по столбцу fare_conditions. Конечно, в реальной ситуации такой индекс вряд ли целесообразен, но нам он нужен для экспериментов.
Проделайте те же эксперименты с таблицей ticket_flights. Будет ли разли- чаться среднее время выполнения запросов для различных значений атрибута fare_conditions? Почему это имеет место?
В завершение этого упражнения отметим, что в случае ошибки планировщи- ка при использовании индекса возможно не только отсутствие положительного эффекта, но и значительный отрицательный эффект


demo=# create index fare_conditions on ticket_flights (fare_conditions);
CREATE INDEX
Time: 1504,070 ms (00:01,504)


demo=# SELECT count( * )
demo-# FROM ticket_flights
demo-# WHERE fare_conditions = 'Comfort';
 count 
-------
 17291
(1 row)

Time: 13,183 ms
Еще раз: Time: 9,360 ms
И еще раз: Time: 9,416 ms
Среднее время = 10,653 ms




demo=# SELECT count( * )
demo-# FROM ticket_flights
demo-# WHERE fare_conditions = 'Business';
 count  
--------
 107642
(1 row)

Time: 100,582 ms
Еще раз: Time:  57,040 ms
И еще раз: Time: 56,436 ms
Среднее время = 71,352 ms




demo=# SELECT count( * )
demo-# FROM ticket_flights
demo-# WHERE fare_conditions = 'Economy';
 count  
--------
 920793
(1 row)

Time: 166,641 ms
Еще раз:  Time: 166,658 ms  
И еще раз: Time: 165,819 ms
Среднее время = 166,373 ms


Сравниваем:

Comfort:  239,254 ms : 10,653 ms
Business:  135,115 ms : 71,352 ms
Economy:  164,427 ms : 166,373 ms

Видим, что лучше всего улучшение во времени у Comfort, у хуже всего - у Economy; но это логично, потому что  Economy больше всего, а Comfort- меньше всего, а индекс дает хорошее улучшение как раз когда доля соответствующих объектов маленькая, и плохую-когда большая.




